"""
Fix Proposal data model.

Represents a proposed fix for an error, which can be a code change
or a configuration/data fix.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional


class FixType(Enum):
    """Type of fix being proposed."""
    CODE_CHANGE = "code_change"           # Modify source code
    CONFIG_CHANGE = "config_change"       # Change configuration
    DATA_INSERT = "data_insert"           # Insert missing data (SQL/Redis)
    DATA_UPDATE = "data_update"           # Update existing data
    MULTIPLE = "multiple"                 # Combination of fixes


@dataclass
class CodeChange:
    """Represents a single code change in a file."""
    file_path: str              # Relative path to file (e.g., "src/translator.cpp")
    original_code: str          # The code to be replaced
    new_code: str               # The replacement code
    line_start: int             # Starting line number
    line_end: int               # Ending line number
    explanation: str            # Why this change fixes the issue


@dataclass
class FixProposal:
    """
    Represents a proposed fix for an error.
    
    This is produced by the fix_generator node and presented
    to the user for confirmation before applying.
    """
    
    # Reference to the error being fixed
    error_summary: str
    
    # Type of fix
    fix_type: FixType
    
    # Title for the PR/commit
    title: str
    
    # Detailed description of what the fix does
    description: str
    
    # Code changes (if fix_type is CODE_CHANGE or MULTIPLE)
    code_changes: List[CodeChange] = field(default_factory=list)
    
    # Configuration changes (if fix_type is CONFIG_CHANGE)
    config_changes: Dict[str, str] = field(default_factory=dict)
    
    # Data operations (SQL/Redis commands) for DATA_INSERT/DATA_UPDATE
    data_operations: List[str] = field(default_factory=list)
    
    # Instructions for manual steps (if any)
    manual_instructions: Optional[str] = None
    
    # Confidence in the fix (0-1)
    confidence: float = 0.0
    
    # Risk level (low, medium, high)
    risk_level: str = "medium"
    
    # Files that will be modified
    affected_files: List[str] = field(default_factory=list)
    
    @property
    def is_code_fix(self) -> bool:
        """Check if this involves code changes."""
        return self.fix_type in (FixType.CODE_CHANGE, FixType.MULTIPLE)
    
    @property
    def requires_pr(self) -> bool:
        """Check if this fix requires a GitHub PR."""
        return self.is_code_fix and len(self.code_changes) > 0
    
    def get_commit_message(self) -> str:
        """Generate a commit message for this fix."""
        return f"fix: {self.title}\n\n{self.description}"
    
    def get_pr_body(self) -> str:
        """Generate PR description body."""
        body = f"## Summary\n{self.description}\n\n"
        body += f"## Error Fixed\n{self.error_summary}\n\n"
        
        if self.code_changes:
            body += "## Changes Made\n"
            for change in self.code_changes:
                body += f"- `{change.file_path}`: {change.explanation}\n"
        
        if self.manual_instructions:
            body += f"\n## Manual Steps Required\n{self.manual_instructions}\n"
        
        body += f"\n---\n*This PR was generated by the Log Analyzer AI Agent*"
        return body
    
    def to_display_string(self) -> str:
        """Format for CLI display."""
        output = [
            f"ğŸ“‹ Fix Proposal: {self.title}",
            f"   Type: {self.fix_type.value}",
            f"   Risk: {self.risk_level}",
            f"   Confidence: {self.confidence:.0%}",
            "",
            f"ğŸ“ Description:",
            f"   {self.description}",
            "",
        ]
        
        if self.code_changes:
            output.append("ğŸ’» Code Changes:")
            for change in self.code_changes:
                output.append(f"   ğŸ“ {change.file_path} (lines {change.line_start}-{change.line_end})")
                output.append(f"      {change.explanation}")
        
        if self.data_operations:
            output.append("ğŸ—ƒï¸ Data Operations:")
            for op in self.data_operations:
                output.append(f"   {op}")
        
        if self.manual_instructions:
            output.append("")
            output.append("âš ï¸ Manual Steps Required:")
            output.append(f"   {self.manual_instructions}")
        
        return "\n".join(output)
    
    def __str__(self) -> str:
        return self.to_display_string()
